<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Perceptron: Interactive Example</title>
    <style>
        /* Replicating the visual style of the MIT Deep Learning slides */
        :root {
            --background-color: #f0f0f0;
            --font-color: #333;
            --title-font: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            --main-font: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            --node-green: #90ee90;
            --node-blue: #add8e6;
            --node-orange: #ffcc80;
            --node-yellow: #fffacd;
            --node-purple: #dda0dd;
            --line-color: #00008b;
            --boundary-color: #4169e1;
            --positive-bg: rgba(144, 238, 144, 0.2); /* Light Green */
            --negative-bg: rgba(173, 216, 230, 0.2); /* Light Blue */
            --accent-red: #d9534f;
        }

        body {
            font-family: var(--main-font);
            background-color: var(--background-color);
            color: var(--font-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: auto;
            margin: 0;
            padding: 0.5rem;
            box-sizing: border-box;
            overflow: hidden;
        }

        .container {
            width: 100%;
            max-width: 1150px;
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            padding: 0.8rem 1.2rem;
            box-sizing: border-box;
        }

        h1 {
            font-family: var(--title-font);
            font-size: 1.6rem;
            font-weight: 500;
            text-align: center;
            margin-top: 0;
            margin-bottom: 0.7rem;
        }

        .main-content {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: flex-start; /* Align to top */
        }

        .left-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
        }

        .perceptron-svg {
            width: 100%;
            max-width: 350px;
            height: auto;
        }

        .draggable-weight {
            cursor: ns-resize;
            user-select: none; /* Prevents text selection during drag */
        }

        .right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #graph-canvas {
            border: 1px solid #ccc;
            border-radius: 8px;
            cursor: crosshair;
            width: 100%;
        }

        .calculations {
            margin-top: 0.5rem;
            font-size: 0.95rem;
            font-family: monospace;
            width: 100%;
            max-width: 350px;
            text-align: center;
            background-color: #f9f9f9;
            padding: 0.6rem;
            border-radius: 8px;
            border: 1px solid #eee;
        }
        
        .activation-container {
            margin-top: 0.5rem;
            width: 100%;
            max-width: 350px;
            text-align: center;
        }

        #sigmoid-canvas {
            width: 100%;
            max-width: 240px;
            margin: 0.3rem auto;
        }

        .activation-container h3 {
            font-size: 1.1rem;
            font-weight: 500;
            margin: 0 0 0.4rem 0;
        }

        .activation-container p {
            font-family: monospace;
            font-size: 0.95rem;
        }

        .instruction-text {
            text-align: center;
            margin-top: 0.3rem;
            color: #666;
            font-style: italic;
            font-size: 0.8rem;
        }

    </style>
</head>
<body>

    <div class="container">
        <h1>The Perceptron: Example</h1>
        <div class="main-content">
            <div class="left-panel">
                <!-- SVG representation of the perceptron diagram -->
                <svg viewBox="0 0 350 200" class="perceptron-svg">
                    <!-- Nodes -->
                    <circle cx="50" cy="40" r="15" fill="var(--node-green)" stroke="#333" stroke-width="1"></circle>
                    <text x="50" y="44" text-anchor="middle" font-size="12">1</text>
                    <circle cx="50" cy="100" r="15" fill="var(--node-blue)" stroke="#333" stroke-width="1"></circle>
                    <text x="50" y="104" text-anchor="middle" font-size="12">x₁</text>
                    <circle cx="50" cy="160" r="15" fill="var(--node-blue)" stroke="#333" stroke-width="1"></circle>
                    <text x="50" y="164" text-anchor="middle" font-size="12">x₂</text>

                    <circle cx="150" cy="100" r="18" fill="var(--node-orange)" stroke="#333" stroke-width="1"></circle>
                    <text x="150" y="105" font-size="20" text-anchor="middle">Σ</text>

                    <circle cx="230" cy="100" r="18" fill="var(--node-yellow)" stroke="#333" stroke-width="1"></circle>
                     <path d="M 222 90 C 225 110, 235 110, 238 90" stroke="#333" stroke-width="1.5" fill="none" transform="translate(0, -10) scale(1, 1.2)"></path>

                    <circle cx="310" cy="100" r="18" fill="var(--node-purple)" stroke="#333" stroke-width="1"></circle>
                    <text x="310" y="105" font-size="16" text-anchor="middle">ŷ</text>

                    <!-- Lines and Weights -->
                    <path d="M 65 45 L 132 95" stroke="#006400" stroke-width="1.5" fill="none"></path>
                    <text id="w0-text" class="draggable-weight" x="95" y="60" font-size="12" fill="#006400" font-weight="bold">1.0</text>
                    <path d="M 65 100 L 132 100" stroke="var(--line-color)" stroke-width="1.5" fill="none"></path>
                    <text id="w1-text" class="draggable-weight" x="95" y="95" font-size="12" fill="var(--line-color)" font-weight="bold">3.0</text>
                    <path d="M 65 155 L 132 105" stroke="var(--line-color)" stroke-width="1.5" fill="none"></path>
                    <text id="w2-text" class="draggable-weight" x="95" y="140" font-size="12" fill="var(--line-color)" font-weight="bold">-2.0</text>
                    
                    <path d="M 168 100 L 212 100" stroke="#d2691e" stroke-width="2" fill="none"></path>
                    <path d="M 248 100 L 292 100" stroke="#333" stroke-width="2" fill="none"></path>
                </svg>

                <div class="calculations" id="calc-display"></div>
                
                <div class="activation-container">
                    <h3>Activation Function</h3>
                    <canvas id="sigmoid-canvas"></canvas>
                    <p>g(z) = 1 / (1 + e⁻ᶻ)</p>
                </div>
            </div>
            <div class="right-panel">
                <canvas id="graph-canvas"></canvas>
                <p class="instruction-text">Drag the point, or drag the weight values up/down!</p>
            </div>
        </div>
    </div>

    <script>
        // --- Get Element References ---
        const canvas = document.getElementById('graph-canvas');
        const ctx = canvas.getContext('2d');
        const sigmoidCanvas = document.getElementById('sigmoid-canvas');
        const sigmoidCtx = sigmoidCanvas.getContext('2d');
        const calcDisplay = document.getElementById('calc-display');
        const w0_text = document.getElementById('w0-text');
        const w1_text = document.getElementById('w1-text');
        const w2_text = document.getElementById('w2-text');

        // --- State Variables ---
        let weights = { w0: 1, w1: 3, w2: -2 };
        let point = { x: -1, y: 2 }; // Initial point from the example
        let isDragging = false;
        let scale, originX, originY, canvasWidth, canvasHeight;
        const range = 5; // Graph will go from -5 to 5 on both axes

        // --- Core Perceptron Logic ---
        function sigmoid(z) {
            return 1 / (1 + Math.exp(-z));
        }

        function calculatePerceptron(x1, x2) {
            const z = weights.w0 + weights.w1 * x1 + weights.w2 * x2;
            const y_hat = sigmoid(z);
            return { z, y_hat };
        }

        // --- Drawing and Update Logic ---
        function toCanvasX(x) { return originX + x * scale; }
        function toCanvasY(y) { return originY - y * scale; }
        function fromCanvasX(cx) { return (cx - originX) / scale; }
        function fromCanvasY(cy) { return (cy - originY) / -scale; }

        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            const { z } = calculatePerceptron(point.x, point.y);
            ctx.fillStyle = z >= 0 ? 'var(--positive-bg)' : 'var(--negative-bg)';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            ctx.beginPath();
            ctx.strokeStyle = '#aaa';
            ctx.lineWidth = 1;
            ctx.moveTo(0, originY);
            ctx.lineTo(canvasWidth, originY); // X-Axis
            ctx.moveTo(originX, 0);
            ctx.lineTo(originX, canvasHeight); // Y-Axis
            ctx.stroke();
            
            ctx.fillStyle = '#333';
            ctx.font = '14px var(--main-font)';
            ctx.fillText('x₁', canvasWidth - 20, originY - 10);
            ctx.fillText('x₂', originX + 10, 20);

            ctx.beginPath();
            ctx.strokeStyle = 'var(--boundary-color)';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 10]);
            
            const epsilon = 1e-6;
            if (Math.abs(weights.w2) > epsilon) {
                const x1_start = -range, x1_end = range;
                const x2_start = (-weights.w1 * x1_start - weights.w0) / weights.w2;
                const x2_end = (-weights.w1 * x1_end - weights.w0) / weights.w2;
                ctx.moveTo(toCanvasX(x1_start), toCanvasY(x2_start));
                ctx.lineTo(toCanvasX(x1_end), toCanvasY(x2_end));
            } else if (Math.abs(weights.w1) > epsilon) {
                const x1_line = -weights.w0 / weights.w1;
                ctx.moveTo(toCanvasX(x1_line), toCanvasY(-range));
                ctx.lineTo(toCanvasX(x1_line), toCanvasY(range));
            }
            ctx.stroke();
            ctx.setLineDash([]);

            const canvasX = toCanvasX(point.x), canvasY = toCanvasY(point.y);
            ctx.beginPath();
            ctx.fillStyle = 'var(--boundary-color)';
            ctx.arc(canvasX, canvasY, 8, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.fillStyle = '#fff';
            ctx.arc(canvasX, canvasY, 4, 0, 2 * Math.PI);
            ctx.fill();
            
            updateCalculations();
            drawSigmoidGraph();
        }

        function drawSigmoidGraph() {
            const w = sigmoidCanvas.width;
            const h = sigmoidCanvas.height;
            const z_range = 5;
            
            sigmoidCtx.clearRect(0,0,w,h);
            sigmoidCtx.strokeStyle = '#aaa';
            sigmoidCtx.lineWidth = 1;
            
            // Axes
            sigmoidCtx.beginPath();
            sigmoidCtx.moveTo(0, h/2);
            sigmoidCtx.lineTo(w, h/2); // Z-axis
            sigmoidCtx.moveTo(w/2, 0);
            sigmoidCtx.lineTo(w/2, h); // Y-axis
            sigmoidCtx.stroke();
            
            // Curve
            sigmoidCtx.beginPath();
            sigmoidCtx.strokeStyle = 'var(--line-color)';
            sigmoidCtx.lineWidth = 2;
            for(let i=0; i < w; i++) {
                const z_val = (i - w/2) * (z_range * 2 / w);
                const y_val = sigmoid(z_val);
                const plotX = i;
                const plotY = h - (y_val * h);
                if (i === 0) sigmoidCtx.moveTo(plotX, plotY);
                else sigmoidCtx.lineTo(plotX, plotY);
            }
            sigmoidCtx.stroke();
            
            // Current point
            const { z, y_hat } = calculatePerceptron(point.x, point.y);
            const pointX = w/2 + (z * w / (z_range*2));
            const pointY = h - (y_hat * h);
            
            sigmoidCtx.beginPath();
            sigmoidCtx.fillStyle = 'var(--accent-red)';
            sigmoidCtx.arc(pointX, pointY, 5, 0, 2 * Math.PI);
            sigmoidCtx.fill();
        }

        function updateCalculations() {
            const { z, y_hat } = calculatePerceptron(point.x, point.y);
            const x1_str = point.x.toFixed(2), x2_str = point.y.toFixed(2);
            const w0_str = weights.w0.toFixed(1), w1_str = weights.w1.toFixed(1), w2_str = weights.w2.toFixed(1);
            const w1_sign = weights.w1 < 0 ? "-" : "+", w1_val = Math.abs(weights.w1).toFixed(1);
            const w2_sign = weights.w2 < 0 ? "-" : "+", w2_val = Math.abs(weights.w2).toFixed(1);
            
            const eq = `ŷ = g(${w0_str} ${w1_sign} ${w1_val}x₁ ${w2_sign} ${w2_val}x₂)`;
            const z_calc = `z = ${w0_str} + (${w1_str}*${x1_str}) + (${w2_str}*${x2_str}) = ${z.toFixed(3)}`;

            calcDisplay.innerHTML = `${eq}<br>${z_calc}<br>ŷ = g(z) ≈ <strong>${y_hat.toFixed(4)}</strong>`;
        }

        function syncUIWithState() {
            w0_text.textContent = weights.w0.toFixed(1);
            w1_text.textContent = weights.w1.toFixed(1);
            w2_text.textContent = weights.w2.toFixed(1);
            draw();
        }

        // --- Setup and Event Listeners ---
        function setupCanvas() {
            const container = canvas.parentElement;
            const size = Math.min(container.clientWidth, 350);
            canvas.width = size;
            canvas.height = size;
            canvasWidth = canvas.width;
            canvasHeight = canvas.height;
            scale = canvasWidth / (range * 2);
            originX = canvasWidth / 2;
            originY = canvasHeight / 2;

            sigmoidCanvas.width = 240;
            sigmoidCanvas.height = 130;

            syncUIWithState(); // Initial draw
        }

        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
        }

        canvas.addEventListener('mousedown', e => {
            isDragging = true;
            const pos = getMousePos(e);
            point.x = fromCanvasX(pos.x);
            point.y = fromCanvasY(pos.y);
            draw();
        });
        canvas.addEventListener('mousemove', e => { if (isDragging) {
            const pos = getMousePos(e);
            point.x = fromCanvasX(pos.x);
            point.y = fromCanvasY(pos.y);
            draw();
        }});
        window.addEventListener('mouseup', () => { isDragging = false; });
        
        canvas.addEventListener('touchstart', e => {
            isDragging = true;
            const pos = getMousePos(e.touches[0]);
            point.x = fromCanvasX(pos.x);
            point.y = fromCanvasY(pos.y);
            draw();
            e.preventDefault();
        }, { passive: false });
        canvas.addEventListener('touchmove', e => { if (isDragging) {
            const pos = getMousePos(e.touches[0]);
            point.x = fromCanvasX(pos.x);
            point.y = fromCanvasY(pos.y);
            draw();
            e.preventDefault();
        }}, { passive: false });
        window.addEventListener('touchend', () => { isDragging = false; });

        function makeWeightDraggable(textElement, weightKey, min, max) {
            let startY, startValue;
            const sensitivity = 50; 

            function handleMouseMove(e) {
                const deltaY = startY - e.clientY;
                let newValue = startValue + deltaY / sensitivity;
                if (newValue < min) newValue = min;
                if (newValue > max) newValue = max;
                weights[weightKey] = newValue;
                syncUIWithState();
            }

            function handleMouseUp() {
                window.removeEventListener('mousemove', handleMouseMove);
                window.removeEventListener('mouseup', handleMouseUp);
            }

            textElement.addEventListener('mousedown', (e) => {
                e.preventDefault();
                startY = e.clientY;
                startValue = weights[weightKey];
                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('mouseup', handleMouseUp);
            });
        }

        makeWeightDraggable(w0_text, 'w0', -5, 5);
        makeWeightDraggable(w1_text, 'w1', -5, 5);
        makeWeightDraggable(w2_text, 'w2', -5, 5);
        
        window.addEventListener('resize', setupCanvas);
        setupCanvas();
    </script>
</body>
</html>

